算法中也包含一种哲学思想。

```
时间，空间互换 =》有舍才有得
分治算法 =》大而化小，小而化了
回溯算法 =》 大不了从头再来
动态规划 =》 开始是成功的一半
贪心算法 =》 贪得无厌常害了自己
```

计算机网络中包含的思想

```
分层理念 =》 系统分层设计。分清职责，降低耦合。
协议设计 =》 系统接口设计
重复传输 =》 分布式架构最终一致性
拥塞控制 =》 负载均衡策略
```

场景复现：

多个接口都需要走以下流程：

``` 
打印入参  =》 校验入参 =》 业务逻辑 =》 打印出参 =》 处理异常
```

这样做的弊端是  当某个步骤需要修改时，需要将所有接口中相应步骤都进行修改，会存在遗漏修改的地方

(相同的能力没有复用)

解决方案一： 抽取工具类

抽取工具类一定程度上都够实现相同能力的复用。但是，还是存在不少的弊端。

如何保证其他使用者一定能使用并正确使用这个工具类？

使用者如何确定使用哪一个工具类？

由此，我们引出了最优解决方案：

解决方案二：模版方法模式

使用模版方法模式具有以下特点：

- 确保了必要环节一定会调用
- 确保调用的顺序一定正确
- 使用方无需感知通用逻辑
- 通用逻辑方便一起升级



造珠子 + 串珠子 =》 责任链模式（非典型） =》流程引擎

业务流程型 流程引擎

```
jbpm ,activity ,flowable ,camunda
```

系统流程型 流程引擎 

```
liteflow 
```

典型的责任链模式中，是执行多个节点中的一个

而流程引擎则是每个节点都执行了（虽然每个节点中都有needExecute方法，这个方法实际上只是一个前置的灰度，但实际上他还是走进了这个节点）

```
流程引擎中的SOLID:
- S(单一职责原则)： 每个“珠子”职责清晰
- O(开闭原则)：业务逻辑新增则新增“珠子”
- D(依赖倒置原则)：流程引擎执行的是抽象的“珠子接口”，具体的“珠子”是使用时注入
```



拆的太猛过犹不及会导致流程编排复杂，难以进行管理。

```
那如何防止过度设计呢？
唯一的办法是：不是让系统强大，而是让系统保持灵活性
```

典型的分层方式:

- MVC：表现层 ==》 逻辑层 ==》 数据层
- MVC+前后端分离： 表现层（前端） ==》 接口层 ==》 逻辑层  ==》数据层
- 领域型设计： 表现层 （前端） ==》 接口层 ==》 服务层  ==》 领域层 ==》 数据层

分层思想虽然好，但落地实践不好搞

像领域驱动型设计中，常见的几种问题有：

- 替换三方依赖困难（DB，框架，中间件等）
- 分层边界不清导致分层“名存实亡”
- 依赖关系跨层的好与坏

解决上述问题的方案：

```
1.解耦利器之：依赖抽象而非具体
2.分层原则之边界 
	 【接口层】：对出入参仅做格式上的校验，不能设计“例如用户是否在黑名单中”这样的校验。
	 【服务层】：负责编排流程，处理RPC请求，控制同异步，不能涉及领域概念。
	 【领域层】：针对领域规则来实现具体的能力。
	 【数据层】：仅对数据做CRUD，不能涉及对数据的额外加工。
```

|      | 严格分层架构                                                 | 松散分层架构                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 利   | 1.改造影响面可控（每一层修改仅影响上层） 2.防止业务逻辑及数据外泄（每一层仅有权限访问下一层包装好的能力和数据） 3.强调持续抽象，能力内聚 | 调用方便，尤其针对简单的取数逻辑（接口层或者服务层直接向数据层取数） |
| 弊   | 简单逻辑也需要层层调用，修改复杂（每层都要改）               | 1.改造影响不可控   2.业务逻辑及数据风险不可控   3. 内聚性容易被破坏（业务逻辑可能散落在各个层上） |

**在整个分层架构中，每一层除了提供向上的能力，也提供向下的保护。**

DDD架构基础概述

```
DDD中基础层：包含数据层以及一些三方的依赖，缓存

DDD中领域层是核心,是稳定的

接口层，服务层，领域层 与 基础层 并非直接依赖，而是依赖抽象出来的接口
```

类似DDD分层架构：

![image-20240323143042099](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240323143042099.png)



```
系统分层：

为什么做系统分层？  提供复用性，降低耦合，提高可读性

如何做系统分层？ 依赖抽象而非具体， 边界规约，严格分层

什么是系统分层？ DDD，洋葱架构，六边形架构
```

**DDD(Domain Driven Design)领域驱动设计:**

![image-20240323144441770](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240323144441770.png)

![image-20240323144613744](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240323144613744.png)

DDD的特点：

- 业务概念No1（以业务领域概念为核心进行建模）
- 大家认知一致（有效对齐所有角色对业务的认知）
- 拆起来方便（高内聚，低耦合，方便拆分微服务）
- 能落地能实践（有一套行之有效的操作方法）

```
DDD设计包括 战略设计和战术设计。
战略设计主要是建立业务模型，划分业务边界，涉及的概念有领域，子域，限界上下文，领域模型。
战术设计主要是将业务模型转化为系统模型，进行代码分层，涉及的概念有实体，值对象，聚合，领域服务，领域事件。
```

 

![image-20240323151125164](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240323151125164.png)

 事件风暴：把相关的人拉起来，根据一套流程来分析业务概念，业务规则和业务过程。

```
梳理领域事件；事件代表某个行为的结果，是业务的重点。从事件可以正推或反推整个业务流程，并呈现其中的各种业务概念。
补充其他要素，如事件，命令，约束（业务规则），策略，参与方/系统
（最为重要的是尽可能让所有角色描述用户故事）
```

![image-20240323152809643](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240323152809643.png)



 





















