## MySQL高级

### 一.Linux上MySQL的卸载，安装与使用

#### 1. MySQL的卸载步骤

1.  关闭MySQL服务
   - systemctl stop mysqld.service
2. 查看Linux上是否有MySQL的安装包
   - rpm -qa | grep -i mysql
3. 使用yum remove 删除安装程序
   - yum remove  安装程序名
4. 通过命令查找MySQL的所有文件
   - find  /  -name mysql
5. 使用命令删除MySQL相关文件
   - rm -rf 文件名
6.  	删除MySQL的配置文件
   - rm -rf /etc/my.cof

#### 2.Linux上MySQL的安装

1. 给/tmp文件夹设置一个比较大的权限

   - chmod -R 777 /tmp

2. 使用rpm安装MySQL程序

   - rpm -ivh RPM包名

3. 初始化root账户

   - mysqld --initialize --user=mysql

4. 查看root账户密码

   cat /var/log/mysqld.log

5. 使用systemctl start mysql.service启动mysql服务
6.  进入MySQL 修改root账户密码

```sql
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{pwd12345}';
```

```sql
flush privileges;
```

### 二.MySQL的数据目录

#### 2.1 linux上字符集的修改与底层原理

1. 进入 /etc/my.cnf文件中 添加 character_set_server = utf8
2. 重启mysql服务 ： systemctl restart mysqld.service

字符集有四个级别:

- 服务器级别
- 数据库级别
- 表级别
- 列级别

>  如果下一个级别没有显示指定字符集，默认使用上一级别的字符集。

比较规则

> utf8_unicode_ci和utf8_general_ci对中，英文来说没有实质的区别
>
> utf8_general_ci校对速度快，但准确度稍差
>
> utf8_unicode_ci准确度高，但校对速度稍慢
>
> 一般情况下，使用utf8_general_ci就可以，如果出现法语，德语和俄语，就要使用utf8_unicode_ci

#### 2.2 SQL大小写规范

MySQL在linux中

- 数据库名，表名，表的别名，变量名严格区分大小写
- 关键字，函数名不区分大小写
- 列名，列的别名在任何情况下都不区分大小写

#### 2.3 目录

- 数据目录； /var/lib/mysql

- 命令目录：/usr/bin ,   /usr/sbin

- 配置文件目录： /etc/my.cnf  ,   /usr/share/mysql-8.0(或 /usr/share/mysql)

#### 2.4 MySQL下默认的库的说明

- mysql：存储了MySQL的用户账户和权限信息，一些存储过程，事件的定义信息，运行过程中产生的日志信息等
- information_schema：存储基础的表，视图，触发器，列，索引等信息
- performance_schema：保存MySQL运行过程中一些状态信息，用来监控M]ySQL服务的各类性能指标
- sys：通过视图的方式把information_schema和performance_schema结合起来



> /var/lib/mysql/ibtmp1 中存储系统表空间,可以存储表数据，默认大小为12M

**解析ibd文件命令**

```
ibd2sdi --dump-file=新文件名.txt  要解析的ibd文件名
```

### 三.用户与权限管理

#### 3.1 用户管理

##### 3.1.1 创建用户

```
create user 用户名 identified by 密码;
```

##### 3.1.2 修改用户

```
update mysql.user set  ...  where user = ?,host = ?;
flush privileges;
```

##### 3.1.3 删除用户

方式一:（推荐使用）

```
drop user 用户名@host名;
```

方式二:

```
delete from mysql.user where host = ? and use = ?;
```

> 该方式不推荐使用，因为可能系统会有残余信息保留，而drop user 则会删除用户信息及对应的权限信息

##### 3.1.4 设置当前用户密码

方式一：使用alter user 对当前用户密码进行修改

```
alter user user() identified by '新密码';
```

方式二:

```
set password = '新密码';
```

当然了，在MySQL5.7当中可以这样操作（不过不建议这样使用，在MySQL8.0中PASSWORD函数被删除了）

```
set password = PASSWORD('新密码');
```

##### 3.1.5 修改其他用户密码

在root账号中对其他用户的密码进行修改

方式一:

```
alter user 用户名@host名 identified by '新密码';
```

方式二:

```
set password for 用户名@host名='新密码';
```

方式三：(不推荐使用)

```
update mysql.user set authentication_string=PASSWORD('新密码') where user=? and host=?;
```

#### 3.2 权限管理

查看权限列表:

```
show grants;
```

##### 3.2.1 授予权限

```
grant 权限1,权限2，... ,权限n on 数据库名.表名 to 用户名@host名 [identified by ‘密码’];
```

赋予所有的权限的命令:

```
grant all privileges on *.* to 用户名@host名;
```

##### 3.2.2 回收权限

```sql
revoke 权限1,权限2, ... ,权限n on 数据库名.表名 from 用户名@host名；
```

##### 3.2.3 权限表

在MySQL中，用户的权限信息存储在user，db，tables_priv，columns_priv，procs_priv等数据表中，当MySQL启动时，MySQL服务器会将这些表中的权限信息加载内存当中。

#### 3.3 用户管理

在MySQL8.0中，新添加了用户管理功能，用来管理具有相同权限的用户，角色是权限的集合。

##### 3.3.1 新建角色

```sql
create role 'role名'@'host名';
```

##### 3.3.2 给角色赋予权限

```sql
grant select,delete ... on 库名.表名 to '角色名‘
```

##### 3.3.3 回收角色

```sql
drop role '角色名';
```

##### 3.3.4 给用户赋予角色

给用户赋予角色后，角色还不起作用。要在角色已经创建并授权后，并且激活了用户的角色，用户的角色才能起作用

```sql
grant '角色名' to '用户名';
```

##### 3.3.5 查看当前用户的角色

```sql
select current_role(); 
```

##### 3.3.6 激活用户角色

方式一:

```sql
set default role '角色名' to '用户名';
```

方式二:将activate_all_roles_on_login设置为ON

```sql
show variables like 'activate_all_roles_on_login';
set global activate_all_roles_on_login = ON;
```

#####  3.3.7 回收角色

```sql
revoke role from '用户名'；
```

### 四.逻辑架构

#### 4.1 逻辑架构

![image-20221008155413280](.\图片\image-20221008155413280.png)

![image-20221008162458389](E:\TyporaNotes\MySQL\图片\image-20221008162458389.png)

MySQL的逻辑架构分为三层，分别为**连接层**，**服务层**，**引擎层**。而l连接层中包括TCP连接池和线程池，服务层又包括SQL接口，解析器，优化器，缓存和缓冲池。

其中，SQL接口的作用是接收用户的SQL命令，并且返回用户需要查询的结果。

> MySQL服务器中有专门的TCP连接池限制连接数，采用长连接模式复用TCP连接。

#### 4.2 SQL执行流程

![image-20221008170824805](.\图片\image-20221008170824805.png)

> 在MySQL5.7中，可以使用命令 
>
> ```sql
> show variables like '%query_cache_type%';
> ```
>
> 来查看缓存是否开启，而在MySQL8.0中，将缓存区给删除了
>
> 使用命令
>
> ```sql
> show global status like 'Qcache%';
> ```
>
> 来查看查询缓存的其他一些信息
>
> **查询缓存中涉及的表，每一个表对象都有一个属于自己的全局性质的锁。**

**解析器**负责对SQL语句的词法和语法进行分析，**生成语法分析树。**

**优化器**进行SQL查询优化，**生成查询计划**。而SQL查询优化包括逻辑查询优化和物理查询优化。

- 逻辑查询优化：通过**SQL等价变换**提升查询效率
- 物理查询优化：通过索引和表连接方式等技术来进行优化

 ##### 4.2.1 查看SQL执行流程

查看profiling是否开启

```sql
show variables like '%profiling';
```

开启profililng 

```sql
set profiling=ON;
```

查看执行计划:

```sql
show profiles;
```

查询指定的执行计划:

```sql
show profile for query 执行计划的id值;
```

##### 4.2.2 数据库缓冲池

> InnoDB存储引擎是以页为单位来管理存储空间的，DBMS会申请一块内存来作为数据库的缓冲池。这样做的好处是可以让磁盘的活动最小化，从而减少与磁盘直接进行I/O的时间。

![image-20221009155939334](.\图片\image-20221009155939334.png)

注意：查询缓存和缓冲池不是同一个东西，他们存储的内容不同，缓冲池中存放的是数据页，而查询缓存中存放的是查询SQL以及查询SQL执行后的结构，MySQL8.0 废弃的是查询缓存。

**查询缓冲池大小**

如果使用的是MyISAM存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为key_buffer_size

如果使用的是InnoDB存储引擎，则使用如下命令:

```sql
show variables like 'innodb_buffer_pool_size';
```

**设置缓冲池大小**

方式一:

```sql
set global innodb_buffer_pool_size = 缓冲池大小;
```

方式二 :在配置问题my.ini 或my.cnf文件中进行如下配置

```sql
[server]
innodb_buffer_pool_size = 缓冲池大小;
```

### 五.存储引擎

查看所有的存储引擎:

```sql
show engines;
```

查看当前使用的存储引擎:

```sql
show variables like '%storage_engines%';
```

修改当前使用的存储引擎:
```sql
set default_storage_engine = 存储引擎名; 
```

#### 5.1 InnoDB存储引擎：具有外键支持的事务型存储引擎

- 除了增加和查询外，还需要更新，删除操作，优先选择使用InnoDB存储引擎
- InnoDB存储引擎是为处理巨大数据量的最大性能设计
- 对比MyISAM存储引擎，InnoDB存储引擎**写处理**效率较差一些
- MyISAM存储引擎只缓存索引，不缓存真实数据,但InnoDB存储引擎不仅缓存索引，还存储真实数据，对内存的要求比较高

- InnoDB存储引擎采用行级锁，而MyISAM存储引擎采用表级锁，在高并发的环境下，InnoDB存储引擎的效率比较高

> NDB存储引擎：MySQL集群专用的存储引擎

### 六.索引的数据结构

**索引的优点：**

- 加快查询速度，**减少与磁盘进行I/O的次数**
- 通过创建唯一索引，可以保证数据的唯一性
- 在使用分组和排序子句时，可以减少分组和排序所花的时间
- 在实现数据的参考完整性方面，可以加速表和表之间的连接。

**索引的缺点：**

- 创建索引和维护索引需要花费一定的时间，而且随着数据量的增加，维护索引所花费的时间也在增加
- 索引需要占用一定的磁盘空间
- 索引可以大大提高查询速度，但一定程度上减慢了新增，删除，更新的速度。因为新增，删除和更新数据后，需要对B+树进行调整。

> 数据页的大小为16KB，因此不建议使用过长的字段作为主键，因为这样会导致一个数据页中存放的数据条数减少，从而导致B+树的层数增加，进而增加与磁盘进行I/O的次数。

#### 6.1 常见的索引概念

索引分为**聚簇索引**和**非聚簇索引**。非聚簇索引又包括联合索引。

聚簇索引不是一种单独的索引类型，而是一种数据存储方式，即所有的用户数据都存储在叶子节点上。所以，在InnoDB存储引擎下，可以说“索引即数据，数据即索引”。

> 聚簇：数据行和相邻的键值聚餐的存储在一起。

- 数据物理存储排序的方式只能有一种，所以每个MySQL的表只能有一个聚簇索引，一般情况下就是该表的主键。
- 如果没有定义主键，InnoDB会选择非空的唯一索引替代
- **InnoDB存储引擎支持聚簇索引，而MyISAM存储引擎不支持聚簇索引**

补充说明:

> 1. 对于二级索引的内节点的目录项记录的内容实际上是由索引列的值，主键值和页号三部分组成，以此来保证内节点的目录记录的唯一性。
> 2. 根页面节点的位置是恒定不变的，在需要创建新的一层索引时，是将根页面节点的数据复制出来创建一个节点，根页面节点的位置保持不变，但存储的内容发生了改变。
> 3. 一个页面最少可以存储两条记录

#### 6.2 MyISAM存储引擎中索引的相关知识和原理

MyISAM存储引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。 

MyISAM存储引擎中使用的都是二级索引，即非聚簇索引，没有所谓的聚簇索引。

#### 6.3 数据库底层使用的数据结构的优势

> InnoDB本身不支持Hash索引，但是提供自适应Hash索引。
>
> - 如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。
> - 查看自适应索引是否开启的命令：show variables like  ' %adaptive_hash_index%';

**B+树和B树的区别：**

- B+树有k个关键字就又k个孩子节点；B树有k个关键字就有k+1个孩子节点

- B+树中所有的数据都保存在叶子节点中，并且所有数据构成一个有序链表；而B树中数据保存在叶子节点和非叶子节点中

- B树非叶子节点也会存储数据，所以B树的层数较B+树来说要多，故在查询效率上B+树要优于B树，即B+树进行I/O的次数要少于B树进行I/O的次数

### 七.InnoDB存储引擎的存储结构

>  磁盘与内存进行交互的基本单位是页，在InnoDB存储引擎中默认页的大小为16KB。

查看当前数据库的存储引擎的页的大小的命令：

```sql
show variables like '%innodb_page_size%';
```

![image-20221012143836136](.\图片\image-20221012143836136.png)

- 表空间从管理上可以划分为系统表空间，用户表空间，撤销表空间，临时表空间等。
- 段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。
- 区在文件系统是一个连续分配的空间，一个区会分配64个连续的页，一个页的大小为1MB。

#### 7.1 页的内部结构

>  页又分为数据页，系统页，Undo 页和事务数据页。

数据页的基本组成:

![image-20221013145009659](.\图片\image-20221013145009659.png)

**页内容的各个组成部分的作用:**

![image-20221013145725532](.\图片\image-20221013145725532.png)

- 文件头和文件尾中都存在校验和和页面被最后修改时对应的日志序列位置，他们两可以用来校验内存与磁盘交换页的完整性。
- 记录会按照**指定的行格式**存储在用户记录中
  - **compact类型的行格式**由**变长字段长度列表，null值列表，记录头信息和记录的真实数据**四部分组成，而记录头信息又由delete_mask，min_rec_mask，record_type ，heap_no，n_owned，next_record 六个字段组成。        
    - MySQL会自动给每个页里添加两条记录，称为伪记录或虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录，最小记录和最大记录的heap_no值分别是0和1。

> 在一个页中，最小记录自成一组，最大记录组中可以包含1-8个记录，而其他组中可以包含4-8个记录

#### 7.2 行格式

查看数据库的行格式:

```sql
select @@innodb_default_row_format;
```

![image-20221020162559942](.\图片\image-20221020162559942.png)

行格式分为四种，compact行格式，dynamic和compressed行格式，redundant行格式。

compact和redundant行格式对于行溢出的处理是将溢出的行存放到其他页中，在每一页中使用20个字节来存储下一页的地址，而dynamic和compressed行格式对于行溢出的处理是将所有溢出的数据放到其他页中，在数据页中存放溢出数据页的地址。

#### 7.3 页，区，段和表空间

> 碎片区属于表空间，不属于某一个段

### 八.索引

#### 8.1 索引的分类

按照类型索引可以分为：普通索引，唯一索引，主键索引和全文索引

按照索引存储方式可以分为：聚簇索引和非聚簇索引

**索引的最左前缀原则**

索引新特性：降序索引(desc)和隐藏索引(invisiable)

> 降序索引只有在mysql8.0以上版本并且使用的是innodb存储引擎才会起作用。

隐藏索引的作用是当将某个索引设置为隐藏索引后，查询优化器不再使用该索引进行查询。

隐藏索引的使用场景：

- 对比使用索引前后，查询的效率
-  删除索引前，使用隐藏索引，验证删除索引后不会对字段造成影响

> 当索引被隐藏后，它的内容和正常索引一样是实时更新的。因此，当一个索引被隐藏后，而数据又频繁的进行新增，修改和删除的话，就可以将这个索引给删除掉， 减少系统开销。

#### 8.2 适合创建索引的11种情况

1. 字段的数值有唯一性的限制

2. 频繁作为where查询条件的字段

3. 经常group by 和 order by 的字段

   > 如果group by 和 order by 一起使用的话，建立联合索引时，将group by 的字段放在联合索引字段的前面，这样提高索引命中率，减少查询时间

4. update，delete的where条件列

5. distinct字段需要创建索引

6. 多表join连接操作时，创建索引

   - 连接表的数量不要超过2张
   - 对where条件创建索引
   - 对用于连接的字段创建索引，并且连接的字段的类型和长度应该一样，这样索引才会起作用

7. 使用列的类型小的创建索引

8. 使用字符串前缀创建索引

   - 区分度公式: select count(distinct left(字符串字段,截取长度) ) / count(*) from 表名      (得出的值越接近1，区分度越好)

9. 使用区分度高的列作为索引

10. 使用频繁的列放到联合索引的左侧

11. 在多个字段都要创建索引的情况下，联合索引优于单值索引
> 建议 单张表中，不超过6个索引

#### 8.3 不适合创建索引的7种情况

1. where中使用不到的字段，不要建立索引
2. 数据量小 （数据量小于1000）的表最好不要建立索引
3. 大量重复数据的字段上不要建立索引  （重复度高于10%就不对该字段建立索引）
4. 避免对经常更新的表创建过多的索引
5. 不建议对无序的字段作为索引
6. 删除不再使用或很少使用的索引
7. 不定义冗余或重复索引（联合索引和普通索引通常容易冗余，需要注意）



### 九.性能分析及性能分析工具的使用

查看慢查询次数:

```sql
show status like 'Slow_queries';
```

开启慢查询:(默认情况下，mysql是不开启慢查询日志的)

> //查询是否开启慢查询日志
>
> show variables like '%slow_query_log%';
>
> set global slow_query_log = ON;
>
> //查询慢查询的最大查询时间
>
> show variable like 'long_query_time';
>
> set global long_query_time = ;
>
> set  long_query_time = ;

使用**mysqldumpslow 命令**可以查询慢查询日志文件中的信息

例如:

```
mysqldumpslow -s t -t 20 日志文件地址
```

上面命令表名查询的出的慢日志按照查询时间进行排列且只列出前面20条记录

可以使用

```
mysqladmin -uroot -p flush-logs slow 
```

命令对慢查询日志进行删除重建

**使用expalin对sql语句进行分析时,**

- type字段的类型有system，const，ref，eq_ref，unique_subquery，index_merge，range
- partitions字段用于记录查询记录所在分区信息
- key_len可以用于判断联合索引的效率

> **索引下推**：在索引遍历过程中，对索引中包含的字段先进行判断，直接过滤掉不满足条件的记录，减少回表次数提高查询效率。
>
> 如果使用explain对sql语句进行分析时,extra字段中显示Using index condition 则表明使用了索引下推

查看是否开启索引下推的命令:

```
show variables like 'optimizer_switch';
```

开启索引下推的命令:

```
set optimizer_switch = 'index_condition_pushdown = ON'
```

> 知识补充：
>
> select ...  from ... order by ...  limit 10 表示只显示前面10条数据



explain的四种输出格式:

- 传统格式
- json格式
- tree格式
- 可视化格式

输出json格式的命令:

```
explain format=json  ......
```

json格式的输出相比于传统格式的输出，它会多一个属性：成本。这个属性可以更好地帮助我们了解sql执行的开销。

> 在explain命令之后，可以输入show warnings查看优化器重写后的sql语句 （注意：show warnings 是另外的单条语句）



#### 分析优化器执行计划：trace 

OPTIMIZER_TRACE：它可以个跟踪优化器做出的各种决策(访问表的方法，开销计算)，将跟踪结果记录到information_schema库的OPTIMIZER_TRACE表中

该功能默认关闭，需要开启trace,并设置格式为json,同时设置trace最大能够使用的内存大小

```
set optimizer_trace='enabled=on',end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000
```

#### MySQL 监控分析视图 sys schema 

```sql
-- 查看是否有冗余的索引
select * from sys.schema_redundant_indexes;
-- 查看是否有未使用的索引
select * from sys.schema_unused_indexes;
-- 查看行锁的阻塞情况
select * from sys.innodb_lock_waits;
```



### 十.索引优化与查询优化

SQL查询优化主要包括物理查询优化和逻辑查询优化。

而物理查询优化又包括索引和表连接方式。逻辑查询优化则是通过SQL的等价变换进行

索引失效的十一种情况：

- 全值匹配我最爱

- 最左前缀法则

  - 联合索引中包含where中的筛选条件就会走联合索引
  - 联合索引可以包含16个字段
  - 过滤条件中使用的索引必须按照索引建立的顺序，一旦跳过，则索引后面的字段无法使用索引

- 主键添加顺序  （建议主键使用atuo_increment自增，如果插入的主键值忽大忽小，会造成页的裂变和记录移位，导致性能损耗）

- 计算，函数，类型转换（手动或自动）导致索引失效

- 范围条件右边的列索引失效 **（实际开发场景中应该注意该点的应用）**

  - So 在创建联合索引时，确定值的列写在前面，范围条件的列写在最后面

- 不等于（!= 或 <>） 索引失效

- is null 可以使用索引，**is not null 无法使用索引** 

  - 在数据表设计时将字段设置为not null 约束，int 类型给默认值0,varchar类型给默认值 ‘’ （空字符串）。

- like以通配符%开头的无法使用索引 

- OR 前后存在非索引的列，无法使用索引

- 数据库和数据表的字符集统一使用utf8mb4

****

**关联查询优化**

1. 左外连接时，最好给被驱动表和驱动表的连接字段添加索引。（如果只能添加一个索引的话，那就给被驱动表的连接字段添加上索引）

   - 左外连接时，left join 左边的表是驱动表，右边的表是被驱动表；

     而右外连接时，right join 右边的是驱动表，左边的是被驱动表。

2. 优化器可以调整**内连接**的驱动表和被驱动表。MySQL优化器会选择数据量小的作为驱动表，数据量大的作为被驱动表（小表驱动大表）；或则是将连接条件有索引的表作为被驱动表

****

**子查询优化**

在MySQL中，可以使用JOIN链接来替代子查询。JOIN连接不需要建立临时表，所以速度比子查询要快。

> So，尽可能使用JOIN连接来替换掉子查询，来提升查询速度。
>
> 尽量不要使用NOT IN 或则 NOT EXISTS，用 LEFT JOIN  xxx ON xxx WHERE xxx IS NULL替代 

****

**排序优化**

> order by 不限制(字段全查)，索引失效

在MySQL中，存在两种排序方式，分别是FileSort排序和Index排序。

FileSort排序需要在内存中对数据进行排序，会消化大量的CPU资源。

>在SQL中，尽量将where和order by 的字段都加上索引，避免出现FileSort排序的情况.

FileSort有两种算法，分别是双路排序和单路排序。

- 双路排序：MySQL4.1之前使用的算法。双路排序是两次扫描磁盘将数据加载到内存当中。第一次是将order by 的字段的数据加载到内存中进行排序，然后根据排序的数据到磁盘中加载其他需要的字段。
- 单路排序：一次性将需要的列加载到磁盘当中，然后在buffer中对order by 的字段进行排序。该方式比较占用buffer的大小。



在无法使用index排序的情况下，只能使用FileSort进行排序；

此时对FIleSort排序的优化点有:

一：增大sort_buffer_size的大小

- 避免因为单路排序时buffer大小不够，需要多次进行I/O操作增加时间消耗

二：增大max_length_for_sort_data的大小

- 当查询列的数据大小 小于 max_length_for_sort_data时，会使用单路算法，而当查询列的数据大小 大于 max_length_for_sort_data时，则会使用双路算法

****

**分页查询优化**

通常情况下，创建覆盖索引能够提高分页查询的性能。

****

**覆盖索引**

覆盖索引：一个索引的字段包含满足查询结果的数据列

覆盖索引的好处:

- 避免InnoDB进行二次查询（也就是回表操作）
- 将随机IO转换成顺序IO加快查询效率  (将磁盘的随机IO转变成索引的顺序IO)

**索引条件下推(ICP)**

Index_condition_pushdown: 联合索引中包含某个字段，但因为查询条件使用该字段无法使用索引，但是可以使用该字段索引数据过滤掉一部分数据再进行回表操作，一定程度上可以减少回表的数据量，加快查询速度

****

**select (*)，select (1) ，select (具体字段)**

使用 select (具体字段)  时，具体字段最好使用二级索引，不要使用聚簇索引，聚簇索引叶子节点放了 该节点所有的信息，相同内存的情况下加载到内存中的数据较二级索引少。 使用select (*) 和 select (1)，系统则会默认选择一个占用空间较少的二级索引进行统计。

**count(具体字段)统计的是非null数据的条数，count(*)和count(1)则统计的条数包括为null的数据**

**总得来说，一般使用count(1)速度比较快**



在程序中尽可能多的使用commit，这样能够提高程序的性能，需求会随着commit所释放的资源而减少。

数据库commit所释放的资源有：

- 回滚段上用于恢复数据的信息
- 被程序语句获得的锁
- redo / undo log buffer中的空间
- 管理上述3种资源中的内部花费

自增id值存在以下几点问题：

- 可靠性不高
  - 存在自增id回溯的问题
- 安全性不高
- 性能差
  - 自增id值在数据库服务器端生成
- 交互多
  - 需要额外执行一次类似last_insert_id()函数才能知道刚才插入的自增值
- 局部唯一性
  - 在分布式系统中，无法保证唯一性

主键id的设计思路：

非核心业务：对应表的主键自增id,如告警，日志，监控等信息

核心业务：主键设计至少应该是全局唯一并且是单调递增的，全局唯一保证在各系统之间都是唯一的

>  在Mysql8.0中可以对uuid中的时间的位置进行调整，将原来的时间低位，时间中位，时间高位 调整为时间高位，时间中位，时间低位，以达到单调递增的要求。同时Mysql8.0去除掉无效的"-"字符串，而且将36位的字符串转变成16位的二进制数字



### 十一.数据库的设计规范

数据库范式，从低阶到高阶分别是 第一范式（1st NF），第二范式（2nd NF)，第三范式（3rd NF），巴斯-科德范式（BCNF），第四范式（4 NF），第五范式（5 NF）。

> - 范式的阶级越高，冗余度越低。
> - 后一级范式比满足其前面所有低阶的范式。

键和相关属性的描述

- 超键：可以唯一标识关系中的元组的一个或多个属性的**集合**。
- 候选键：超键中不包含多余属性的就是候选键
- 主键：候选键中选出一个或多个属性
- 主属性：包含在任一候选键中的属性

> 主键是超键的子集，是超键的一种特殊情况；主键要满足唯一性，非空性，最小性

**五大范式概述**

> - 第一范式（1st NF）：数据表中每个字段的值必须具有原子性，即每个字段的值都是不可拆分的最小单元。
> - 第二范式（2nd NF）：满足数据表中的**每一条数据记录都是可唯一标识的（ 存在主键）**。而且所有的非主键字段，都必须完全依赖主键，不能只依赖主键的一部分（也就是说只有给定所有的主键才能唯一确定一条非主键字段）。
>   - 该范式中提到的主键字段可以使用主属性 ，也就是说非主属性必须完全依赖主属性或主键。
> - 第三范式（3rd NF）：确保数据表中的每一个非主键字段（非主属性）都和主键字段**直接相关**，即要求数据表中的所有非主键字段不能依赖于其他非主键字段。
> - 巴斯-科德范式（BCNF）：只有一个候选键或则候选键都是单属性。
>   - 引入BCNF的作用在于在3rd NF的基础上消除了主属性对候选键的部分依赖或则传递依赖关系。
> - 第四范式（4 NF）：在BC-NF的基础上，消除了非平凡依赖和非函数依赖的多值依赖（即把同一表内的多对多关系删除）
>   - 多值依赖：
>   - 函数依赖：
>   -  平凡依赖：
>   - 非平凡依赖：
>
> - 第五范式（5 NF）：关系模式R中的每一个连接依赖均由R的候选键所隐含。
>   -  消除了不是候选键所蕴含的连接依赖
****

**外键约束使用**

注：

​	外键约束只有在使用InnoDB存储引擎的时候才能生效，使用MyISAM存储引擎的时候外键约束不生效。

外键约束是在数据库层面上保证数据的一致性，理论上使用外键约束性能上有所下降，因为在插入和删除数据时会检查外键。

### 十二 优化策略

分析表命令:

analyze table 表名;  //更新索引的区分度

检查表命令：

check table 表名; //检查表中是否有错误

优化表:

optimize table 表名;

一般情况下不需要执行该命令，只有在对可变字段,text,blob类型数据进行大量更新，删除的操作下，执行该命令可以整理碎片，节省存储空间

```
检查表和优化表在执行过程中都会给表添加只读锁
```



### 十三.事务

ACID

- 原子性(A)：一组事务操作，要么全部成功，要么失败进行回滚。
- 一致性(C)：事务操作，从一种合法状态改变成另一种合法状态，这种合法状态是语义上的合法，而非语法上的合法，是要根据业务定义的，比如转账业务，转出的金额不能大于账户所持有的金额。
- 隔离性(I)：一个事务的执行不会被其他事务所干扰。
- 持久性(D)：一个事务一旦提交了，对数据库中的数据的改变是永久的。

```
原子性是基础，隔离性是手段，一致性是约束条件，而持久性是最终的目的。
```

一个事务只有处于提交的或则中止的状态，这个事务的生命周期才算结束。

```
手动将mysql的自动提交关闭，只对DML有效，对DDL无效。
```

在自动提交关闭的情况下，以下几种情况会进行隐式地提交:

1. 数据定义语言(DDL)：如create,alter,drop等语句
2. 隐式使用或修改mysql数据库中的表
3. 事务控制或锁定的语句
   - 一个事务没有提交或没有进行回滚的情况下，又开启了一个事务
   - autocommit从off改到on的时候，会隐式提交
   - 锁定表，解锁表的时候
4. 使用load data批量加载数据到数据库的时候
5. 还有一些特定的语句，比如 分析表，检查表，优化表等语句

隔离级别是不同事务之间，查询数据的影响，对于同一事务的数据，不管是否提交都能查询到

#### 数据并发问题

脏写（针对update行为的 ）：一个事务在另一个事务没有提交其数据之前，修改了这个事务的数据。如果另外一个事务进行了回滚操作，就可能会导致数据不一致问题。比如说，另一个事务回滚了，那么数据就会回到事务未修改之前的状态。

脏读(针对select行为的  )：一个事务读取了另外一个修改了但没有提交的数据，如果另外一个事务进行了回滚，那么这个事务读取到的是**临时且无效的数据**。

不可重复读(针对update行为的 )：一个事务读取了某个字段，之后另外一个事务对这个字段进行了修改并进行了提交，而后这个这个事务读取了相同字段，这时候就会发现，前后两次读取的数据不一致，我们把这种现象叫做不可重复读。

幻读(针对insert行为的 )：一个事务读取了某个字段某个区间的数据，之后另一个事务添加了几条在这个区间字段的数据，而后这个事务又去查询这个字段的这个区间的数据，此时会发现，会比第一次多查出来几条数据，我们把这种现象叫做幻读

```
特别注意：如果另外一个事务进行的是删除操作，我们把这种现象叫做不可重复读，而不是幻读，幻读只是针对插入操作的
```

#### 四种隔离级别

- 读未提交
- 读已提交
- 可重复读 （解决不可重复读的问题的原因是在事务开始时创建了一个数据快照，并在整个事务期间都使用这个快照。因此，其他事务对该数据的修改在该隔离级别下是不可见的，即使修改的数据已经提交了）
- 可串行化



### 十四.事务日志

```
事务的隔离性是由锁机制实现的
事务的持久性是由redo日志 （重做日志）来保证的
事务的原子性，一致性是由undo日志（回滚日志）来保证的 
```

redo和undo日志都可以视为一种恢复操作。

```
redo日志和undo日志都是存储引擎层生成的日志，但是redo日志记录的是“物理级别”上的页修改操作，比如：页大小，页偏移量等参数的记录，redo log 是物理日志，记录的是数据页的物理变化，而undo日志记录的是逻辑操作日志，比如对一行数据进行了insert语句，在undo日志中记录的是与之相反的delete操作，用于回滚操作和一致性非锁定读（mvcc:undo 日志回滚行记录到某种特定的版本）。
```

补充知识：

mysql在读取数据时，会将磁盘中的数据以页为单位读取到内存中；在更新数据时，先修改的是内存页中的数据，然后将更新缓冲池中的数据，最后将缓冲池中的脏页以一定的频率刷新到磁盘中去。

#### redo 日志

redo日志主要用于保证数据的持久性，当数据在内存层面进行更新后，系统宕机了，为了保证数据在磁盘中的持久性，使用redo日志来进行恢复。

redo日志的好处在于降低了刷盘（刷新到磁盘）的频率，而且redo日志所占用的空间较小，刷盘的速度也比较快。

redo log 和bin log 的区别

```
redo log 是存储引擎层生成的日志，而bin log则是数据库层生成的日志,redo log 在事务执行过程中，会不断进行 记录，而bin log则是只有事务提交之后才会进行记录。
```

![image-20240220151558840](https://raw.githubusercontent.com/renghongwen/charbed/main/img/Snipaste_2024-02-20_15-17-02.png)

mysql可以通过变量Innodb_flush_log_at_trx_commit修改redo log buffer刷新到redo log file 的 刷新策略。有三种刷新策略。

 ![image-20240220164043773](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240220164043773.png)

#### undo日志

```
undo log 的产生页会伴随着redo log 的产生，因为undo log 也需要持久化的保护。
undo log 是逻辑日志，只是逻辑上进行回滚，并非物理层面上的回滚，数据结构和数据页回滚后可能和原来不同。
```

每个事务只会使用一个回滚段，而一个回滚段在同一时刻可能会服务多个事务。

```
事务提交后不能马上删除undo log和undo log所在的页，因为回滚段重用机制可能存在其他事务需要通过undo log来获得行记录之前的数据
```

补充知识：
**Insert操作的记录只对当前事务可见，对其他事务不可见（事务隔离性的要求）**

注意:

​	undo log 不是redo  log的逆过程。 



### 十五.锁

并发问题的两种解决方法:

- 读使用mvcc(一致性非锁定读),写使用锁 ,这种方式并发性能更高
- 读写都使用锁

一般情况下，采用mvcc来解决并发执行的问题，但是一些特殊业务场景下，还是必须使用加锁来解决并发问题 （如：银行业务中存钱业务）

![image-20240221155526472](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240221155526472.png)

对于读操作，我们可以添加共享锁，也可以添加排他锁；但是对于写操作，我们只能添加排他锁。

对读取的记录加S锁：

```
select  ... lock in share mode;
或 
select ... for share (8.0写法)
```

对读取的记录加X锁:

```
select ... for update
```

对于新增操作来说，新增一条记录的操作并不加锁，是通过一种称之为**隐式锁**的结构来**保护这条新插入的记录在本事务提交前不被别的事务访问。**



按照锁粒度对锁进行区分可以分为表级锁，页级锁，行锁。

#### 一.表级锁

表级锁是粒度较大，开销最小的锁，表级锁一次将整个表给锁定住了，故不会有死锁的产生。

表级锁有包含S锁，X锁，意向锁，自增锁，元数据锁。

加表级锁后，当前事务和其他事务是否可操作如下图所示：

![image-20240222101320538](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240222101320538.png)

```
表加读写锁后，当前事务都不可以操作其他表。 这点需要特别注意，表读写锁限制还是挺大的哈。
```

一般情况下，使用MyIsam存储引擎的表加的是表级锁，使用Innodb存储引擎的表加的是行锁，当然了，使用Innodb存储引擎的表也可以手动设置使用表级别的S锁和X锁。

手动给Innodb表设计表级锁的命令是

```
lock tables 表名 read; # 加S锁
lock tables 表名 write; # 加X锁
```

##### 1)意向锁

 意向锁是Innodb存储引擎支持的多粒度多，它允许行级锁与表级锁共存。意向锁和行级锁不冲突。

意向锁解决的问题场景是:

```
如果我给某一行数据加上了排它锁，数据库会自动的给更大一级的空间，比如数据页或是数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了。这样的话，如果要给表加上表级锁，就不用遍历数据表中所有的数据判断所有的数据是否加上了行级锁。
```

意向共享锁:

```
select column from 表名 ... lock in share mode;
```

意向排它锁:

```
select column from 表名 ...  for update;
```

意向锁的几点特性:

- 意向锁之间互不排斥，但除了IS和S兼容外，意向锁会与共享锁/排它锁 互斥。
- IS，IX是表级锁，不会和行级的X，S锁发生冲突，只会和表级的S，X发生冲突。
- 意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。

##### 2)自增锁

补充知识:

数据插入的三种方式:

- 简单方式（simple inserts）： 预先确定要插入的行数，如insert ... values 和replace语句。
- 批量插入（Bulk inserts）： 事先不知道要插入的行数，如insert ... select 和 replace ... select 和 load data语句。
- 混合模式插入（Mixed-mode inserts）： insert ... values 中部分指定id，部分不指定id。

在数据插入时，生成自增id主键时，会设置一个表锁。

##### 3)元数据锁(MDL锁)

元数据锁是隐式锁，不需要我们手动添加。

- 当对一个表做增删改查操作的时候，加MDL读锁；当要对表结构变更操作的时候，加MDL写锁。

#### 二.行锁

行锁只存储在存储引擎层实现。

##### 1）记录锁（Record Lock）

也就是行锁，记录锁也区分为S锁和X锁。其加锁命令和加表锁的命令一样。

##### 2）间隙锁（Gap Lock）

间隙锁的提出仅仅是为了防止插入幻影记录而提出的。共享gap锁和独占gap锁它们起到的作用是相同的。如果对一条记录加了gap锁（不论是共享gap锁和独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。但是如果对这条加了间隙锁的记录，就不能进行新增了。  

**对不存在的数据进行加锁，即加的就是间隙锁。**

```
MySql在隔离级别为可重复读的级别下是可以解决幻读的问题的。解决方案有两种，可以使用mvcc，也可以 使用加锁的方式。
一般情况下，使用mvcc效率较高，特殊场景下就必须加锁进行解决。
```

间隙锁会有死锁的情况产生。

```
间隙锁只会阻塞insert,而记录锁会阻塞任意的锁。
```

##### 3) 临键锁 （Next-Key Locks）

临键锁本质上是记录锁和gap锁的合体。Innodb默认的锁就是临键锁。

临键锁既可以锁住当前记录，又可以**锁住记录前边的间隙**。

##### 4）插入意向锁

插入意向锁是一种Gap锁，不是意向锁。在insert操作中产生。

```
Innodb规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。
```

插入意向锁并不会阻止其他事务继续获取记录上任何类型的锁。

#### 三.页锁

```
每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数据超过了这个层级的阀值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁。
```

#### 四.悲观锁，乐观锁

##### 1）悲观锁

悲观锁：通过数据库加锁进行实现的，例如，S锁，X锁等。Java 中synchronized和ReentrantLock等独占锁。

- 对于长事务来说，悲观锁的开销比较大。

补充知识:

```
select ... for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。
```

##### 2）乐观锁

乐观锁：通过程序判断进行实现的。例如，我们在数据表中添加version字段，通过判断version字段的值来判断是否有线程操作当前数据。

乐观锁适用于多读的应用类型，可以采用版本号机制或则CAS机制实现。

- 乐观锁的版本号机制
- 乐观锁的时间戳机制

注意:

```
如果数据表使用的是读写分离的表，这时候就要强制读master表中数据，要不然就会出现更新失效的问题。
```

#### 五.显式锁，隐式锁

要注意区分隐式锁和插入意向锁

```
插入意向锁是在有间隙锁的存在的时候，执行insert操作。
```

补充内容：

```
对于聚簇索引来说，有一个trx_id隐藏列，记录这最后改动该记录的事务id。
而对于二级索引来说，本身没有trx_id隐藏列，在二级索引页中的Page Header部分有一个PAGE_MAX_TRX_ID，代表对该页面做改动的最大的事务id.通过比较事务id大小来判断当前事务能否操作该记录。
```

隐式锁是一种延迟加锁的机制，就是说当A事务执行insert操作，B事务对A事务insert的记录加锁，此时，B事务就会。触发A事务给insert的记录加一个隐式锁。

#### 六.全局锁，死锁

##### 1）全局锁

全局锁的使用场景是全库做逻辑备份。

使用上了全局锁之后，整个库就处于只读状态了。

加全局锁的命令:
```
flush tables with read lock
```

##### 2）死锁

死锁解决的方式:

- 等待，直到超时（innodb_lock_wait_timeout） 。  设置一个阈值，当一个事务等待时间超过这个阈值时，就将其进行回滚。 （对于在线服务来说，50s的超时等待时间比较久，会影响用户的体验。）
- 使用死锁检测进行死锁处理。   使用wait-for graph 等待图算法 主动检测是否有死锁 。一旦检测到回路，有死锁，InnoDB存储引擎就会选择回滚undo量最小的事务。

#### 七.锁结构

符合以下条件的记录会放到一个锁结构中:

- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的

只有同时满足上述条件，记录才会放到同一个锁结构中

![image-20240227091705245](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240227091705245.png)

#### 八.锁监控

```
通过show status like 'innodb_row_lock%';查看锁的一些情况。
```

```
通过select * from performance_schema.data_lock_waits; 查看当前锁等待的事务。
```

#### 十六.多版本并发控制(MVCC)

MVCC(Multiversion Concurrency Control)

MVCC是通过数据行的多个版本管理来实现数据库的并发控制

```
MVCC就是生成一个ReadView，通过ReadView找到符合条件的记录版本（历史版本由undo日志构建）。查询语句只能读到在生成ReadView之前提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。
```

##### 1）快照读

快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。

##### 2）当前读

当前读读取的是记录的最新记录。

**MVCC的实现依赖于:隐藏字段，Undo Log,Read View**

```
InnoDb,MVCC是通过Undo Log + Read View 进行数据读取，Undo Log保存了历史快照,而Read View规则帮我们判断当前版本的数据是否可见。
```

- 当隔离级别是读已提交时，一次事务中每一次SELECT查询都会重新获取一次Read View。
- 当隔离级别是可重复读时，一次事务只在第一次SELECT的时候获取一次Read View，这样就可以避免不可重复读。

MVCC解决的问题：

- 读写之间阻塞的问题。
- 降低了死锁的概率。MVCC采用了乐观锁的方式,
- 解决了快照读的问题。

#### 十七.日志文件

日志共分为以下几种类型：

- 重做日志 (redo log)
- 回滚日志(undo log)
- 二进制日志(bin log)：记录所有**更改数据**的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
- 通用查询日志(general query log)：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令
- 慢查询日志(slow query log)
- 错误日志(error log)

mysql8.0新增了以下两种日志:

- 中继日志（relay log）：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。
- 数据定义语句日志

##### 1）通用查询日志

```
通过show variables like '%general%';查询通用查询日志的相关配置信息
```

一般情况下，通用查询日志是关闭的。

```
使用mysqladmin -uroot -p flush-logs 重新生成日志文件
```

##### 2）错误日志

```
通过show variables like '%log_err%';查看error log 日志文件存储的问题
```



错误日志默认是开启的，而且，错误日志是无法被禁止的。

```
重新生成错误日志需要使用
install -omysql -g mysql -m0644 /dev/null 错误日志文件地址 
重新生成错误日志文件，而后使用
mysqladmin -uroot -p flush-logs 
刷新显示日志文件
```

##### 3）二进制日志

bin log的使用场景：

- 数据恢复
- 数据复制

bin log 是以事件形式记录并保存在二进制文件中的。

```
数据库文件最好不要与日志文件放在同一磁盘下。
```

查看bin log 文件的命令（以伪sql的形式进行展示）

```
mysqlbinlog -v --base64-output=DECODE-ROWS binlog文件地址
```

或者

```
show binlog events in  binlog文件名 [ from pos limit offset,row_count]
```

binlog 的两个格式:

- Statement ： 保存修改数据的sql语句在binlog中
- Row：仅保存哪条记录被修改了

使用bin log 进行数据恢复的命令如下:

```
mysqlbinlog --start-position= --stop-position=  --database=     binlog文件地址 | mysql -uroot -p密码 -v 数据库名称
```

###### 二进制文件删除

```
purge master|binary logs to '指定日志文件名'
删除指定文件之前的二进制日志文件
```

bin log 写入磁盘的机制:

![image-20240229141601453](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240229141601453.png)

###### bin log 和redo log的对比

redo log是物理日志，记录的是数据页的变化情况，是存储引擎层生成的,redo log 让innodb 存储引擎有崩溃恢复能力。

bin log则是逻辑日志，记录的是数据的变化情况，即语句的原始逻辑，它则保证的是MySQL集群架构的数据一致性。

redo log在事务执行过程中会不断写入，而bin log 则是只有事务提交之后才会进行写入。

###### 两阶段提交

为了解决redo log 和bin log两份日志之间的逻辑一致问题，Innodb存储引擎使用两阶段提交方案。

```
两阶段提交方案也就是更新数据后，先写入redo log (prepare阶段)，提交事务之后，写入bin log日志，在redo log设置commit阶段。  如果在写入redo log (prepare阶段)后，写入bin log 日志前,mysql崩溃了，则进行事务的回滚操作，使数据保持同步。
```

##### 4）中继日志

中继日志默认保存在从服务器的数据目录下。

#### 十八.主从复制

主从复制的作用: 

- 读写分离
- 数据备份：相当于是热备份机制
- 具有高可用性

主从复制原理图：

![image-20240301100119873](https://raw.githubusercontent.com/renghongwen/charbed/main/img/image-20240301100119873.png)

主从复制过程中使用到了三个线程：

1. 二进制日志转储线程：将主库中的二进制文件发送给从库。
2. 从库I/O线程：连接主库，向主库发送请求更新bin log。
3. 从库sql线程：读取从库中的中继日志，并执行日志中的时间。

补充知识:

```
在使用虚拟机克隆时，需要对克隆出来的机器修改一下配置：1.mac地址 （修改虚拟机中的mac地址信息）2.hostname 3.ip地址 4.机器uuid 5.mysql server uuid （修改 /var/lib/mysql/auto.cnf文件内容）
两台虚拟机上述配置不能一样，需要重新生成或者进行修改
```

主从复制配置文件my.cnf中binlog格式

- statement模式(默认):每一条修改的sql语句都会记录到binlog中
- row模式：不记录每条sql语句的上下文信息，仅记录哪条数据进行了什么修改
- mined模式：statement和row模式的结合



**主从复制下的同步数据一致性问题**

解决方案：

- 异步复制：效率高，但一致性较差
- 半同步复制：等待从库返回通知，再返回写结果
- 组复制：



#### 十九.数据库备份与恢复

备份：

- 物理备份：备份数据文件(idb文件)，mysql中可以使用xtrabackup进行备份
- 逻辑备份：备份sql语句，mysql中常用的备份工具是mysqldump































