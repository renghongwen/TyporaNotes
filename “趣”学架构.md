算法中也包含一种哲学思想。

```
时间，空间互换 =》有舍才有得
分治算法 =》大而化小，小而化了
回溯算法 =》 大不了从头再来
动态规划 =》 开始是成功的一半
贪心算法 =》 贪得无厌常害了自己
```

计算机网络中包含的思想

```
分层理念 =》 系统分层设计。分清职责，降低耦合。
协议设计 =》 系统接口设计
重复传输 =》 分布式架构最终一致性
拥塞控制 =》 负载均衡策略
```

场景复现：

多个接口都需要走以下流程：

``` 
打印入参  =》 校验入参 =》 业务逻辑 =》 打印出参 =》 处理异常
```

这样做的弊端是  当某个步骤需要修改时，需要将所有接口中相应步骤都进行修改，会存在遗漏修改的地方

(相同的能力没有复用)

解决方案一： 抽取工具类

抽取工具类一定程度上都够实现相同能力的复用。但是，还是存在不少的弊端。

如何保证其他使用者一定能使用并正确使用这个工具类？

使用者如何确定使用哪一个工具类？

由此，我们引出了最优解决方案：

解决方案二：模版方法模式

使用模版方法模式具有以下特点：

- 确保了必要环节一定会调用
- 确保调用的顺序一定正确
- 使用方无需感知通用逻辑
- 通用逻辑方便一起升级



造珠子 + 串珠子 =》 责任链模式（非典型） =》流程引擎

业务流程型 流程引擎

```
jbpm ,activity ,flowable ,camunda
```

系统流程型 流程引擎 

```
liteflow 
```

典型的责任链模式中，是执行多个节点中的一个

而流程引擎则是每个节点都执行了（虽然每个节点中都有needExecute方法，这个方法实际上只是一个前置的灰度，但实际上他还是走进了这个节点）

```
流程引擎中的SOLID:
- S(单一职责原则)： 每个“珠子”职责清晰
- O(开闭原则)：业务逻辑新增则新增“珠子”
- D(依赖倒置原则)：流程引擎执行的是抽象的“珠子接口”，具体的“珠子”是使用时注入
```



拆的太猛过犹不及会导致流程编排复杂，难以进行管理。

```
那如何防止过度设计呢？
唯一的办法是：不是让系统强大，而是让系统保持灵活性
```

典型的分层方式:

- MVC：表现层 ==》 逻辑层 ==》 数据层
- MVC+前后端分离： 表现层（前端） ==》 接口层 ==》 逻辑层  ==》数据层
- 领域型设计： 表现层 （前端） ==》 接口层 ==》 服务层  ==》 领域层 ==》 数据层

分层思想虽然好，但落地实践不好搞

像领域驱动型设计中，常见的几种问题有：

- 替换三方依赖困难（DB，框架，中间件等）
- 分层边界不清导致分层“名存实亡”
- 依赖关系跨层的好与坏

解决上述问题的方案：

```
1.解耦利器之：依赖抽象而非具体
2.分层原则之边界 
	 【接口层】：对出入参仅做格式上的校验，不能设计“例如用户是否在黑名单中”这样的校验。
	 【服务层】：负责编排流程，处理RPC请求，控制同异步，不能涉及领域概念。
	 【领域层】：针对领域规则来实现具体的能力。
	 【数据层】：仅对数据做CRUD，不能涉及对数据的额外加工。
```

|      | 严格分层架构                                                 | 松散分层架构                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 利   | 1.改造影响面可控（每一层修改仅影响上层） 2.防止业务逻辑及数据外泄（每一层仅有权限访问下一层包装好的能力和数据） 3.强调持续抽象，能力内聚 | 调用方便，尤其针对简单的取数逻辑（接口层或者服务层直接向数据层取数） |
| 弊   | 简单逻辑也需要层层调用，修改复杂（每层都要改）               | 1.改造影响不可控   2.业务逻辑及数据风险不可控   3. 内聚性容易被破坏（业务逻辑可能散落在各个层上） |

**在整个分层架构中，每一层除了提供向上的能力，也提供向下的保护。**

DDD架构基础概述

```
DDD中基础层：包含数据层以及一些三方的依赖，缓存

DDD中领域层是核心,是稳定的

接口层，服务层，领域层 与 基础层 并非直接依赖，而是依赖抽象出来的接口
```





















